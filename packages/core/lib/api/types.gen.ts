// This file is auto-generated by @hey-api/openapi-ts

import type { RealtimeRequestCommandEnum, RealtimeResponseCommandEnum } from './reqMap';

export type RealtimeRealtimeAudioFormat = string | ('pcm16' | 'g711_ulaw' | 'g711_alaw');

export type RealtimeRealtimeAudioInputTranscriptionModel = string | 'whisper-1';

export interface RealtimeRealtimeAudioInputTranscriptionSettings {
  model?: RealtimeRealtimeAudioInputTranscriptionModel;
}

export interface RealtimeRealtimeContentPart {
  type: RealtimeRealtimeContentPartType;
}

export type RealtimeRealtimeContentPartType = string | ('input_text' | 'input_audio' | 'text' | 'audio');

/**
 * The definition of a function tool as used by the realtime endpoint.
 */
export type RealtimeRealtimeFunctionTool = RealtimeRealtimeTool & {
  type: 'function';
} & {
  type: 'function';
  name: string;
  description?: string;
  parameters?: unknown;
};

export type RealtimeRealtimeItemStatus = string | ('in_progress' | 'completed' | 'incomplete');

export type RealtimeRealtimeItemType = string | ('message' | 'function_call' | 'function_call_output');

export type RealtimeRealtimeMessageRole = string | ('system' | 'user' | 'assistant');

export type RealtimeRealtimeRequestAssistantMessageItem = RealtimeRealtimeRequestMessageItem & {
  role: 'assistant';
} & {
  role: 'assistant';
  content: Array<RealtimeRealtimeRequestTextContentPart>;
};

export type RealtimeRealtimeRequestAudioContentPart = RealtimeRealtimeContentPart & {
  type: 'input_audio';
} & {
  type: 'input_audio';
  transcript?: string;
};

/**
 * A base representation for messages sent by the client to the service.
 */
export interface RealtimeRealtimeRequestCommand {
  type: RealtimeRealtimeRequestCommandType;
  event_id?: string;
}

// export type RealtimeRealtimeRequestCommandType = string | ('session.update' | 'input_audio_buffer.append' | 'input_audio_buffer.commit' | 'input_audio_buffer.clear' | 'conversation.item.create' | 'conversation.item.delete' | 'conversation.item.truncate' | 'response.create' | 'response.cancel');
export type RealtimeRealtimeRequestCommandType = string | (RealtimeRequestCommandEnum | `${RealtimeRequestCommandEnum}`);

export type RealtimeRealtimeRequestFunctionCallItem = RealtimeRealtimeRequestItem & {
  type: 'function_call';
} & {
  type: 'function_call';
  name: string;
  call_id: string;
  arguments: string;
  status?: RealtimeRealtimeItemStatus;
};

export type RealtimeRealtimeRequestFunctionCallOutputItem = RealtimeRealtimeRequestItem & {
  type: 'function_call_output';
} & {
  type: 'function_call_output';
  call_id: string;
  output: string;
};

export type RealtimeRealtimeRequestInputAudioBufferAppendCommand = RealtimeRealtimeRequestCommand & {
  type: 'input_audio_buffer.append';
} & {
  type: 'input_audio_buffer.append';
  audio: string;
};

export type RealtimeRealtimeRequestInputAudioBufferClearCommand = RealtimeRealtimeRequestCommand & {
  type: 'input_audio_buffer.clear';
} & {
  type: 'input_audio_buffer.clear';
};

export type RealtimeRealtimeRequestInputAudioBufferCommitCommand = RealtimeRealtimeRequestCommand & {
  type: 'input_audio_buffer.commit';
} & {
  type: 'input_audio_buffer.commit';
};

export interface RealtimeRealtimeRequestItem {
  type: RealtimeRealtimeItemType;
  id?: string;
}

export type RealtimeRealtimeRequestItemCreateCommand = RealtimeRealtimeRequestCommand & {
  type: 'conversation.item.create';
} & {
  type: 'conversation.item.create';
  previous_item_id?: string | undefined;
  item: RealtimeRealtimeRequestItem;
};

export type RealtimeRealtimeRequestItemDeleteCommand = RealtimeRealtimeRequestCommand & {
  type: 'conversation.item.delete';
} & {
  type: 'conversation.item.delete';
  item_id: string;
};

export type RealtimeRealtimeRequestItemTruncateCommand = RealtimeRealtimeRequestCommand & {
  type: 'conversation.item.truncate';
} & {
  type: 'conversation.item.truncate';
  item_id: string;
  content_index: number;
  audio_end_ms: number;
};

export type RealtimeRealtimeRequestMessageItem = RealtimeRealtimeRequestItem & {
  type: 'message';
} & {
  type: 'message';
  role: RealtimeRealtimeMessageRole;
  status?: RealtimeRealtimeItemStatus;
};

export interface RealtimeRealtimeRequestMessageReferenceItem {
  type: 'message';
  id: string;
}

export type RealtimeRealtimeRequestModel = string | 'gpt-4o-realtime';

export type RealtimeRealtimeRequestResponseCancelCommand = RealtimeRealtimeRequestCommand & {
  type: 'response.cancel';
} & {
  type: 'response.cancel';
};

/**
 * Trigger model inference to generate a model turn, the response will be streamed back with
 * a series of events, starting with an add_message event and ending with a turn_finished event.
 * If functions are enabled the response may be two, the second being a tool_call.
 *
 * Fields:
 * - conversation_label: References a conversation. If empty or set to a label that does not exist,
 * Generate will create a new conversation, otherwise it will be based on the context of the
 * existing conversation.
 * - commit: If true, the generated messages will be appended to the end of the conversation.
 * Only valid if conversation_label is set.
 * - cancel_previous: If True, the generation will cancel any pending generation for that specific
 * conversation. If False, the generation will be queued and will be generated after the
 * previous generation has completed.
 * - append_messages: If set, these messages will be appended to the end of the conversation before
 * a response is generated. If commit is false, these messages will be discarded. This can only
 * be done with an existing conversation, and thus will throw an error if conversation_label is
 * not set or does not exist.
 * - messages: If conversation_label is not set or does not exist, this will be the initial messages
 * of the conversation, i.e. the context of the generation. If the conversation exists, this will
 * throw an error.
 */
export type RealtimeRealtimeRequestResponseCreateCommand = RealtimeRealtimeRequestCommand & {
  type: 'response.create';
} & {
  type: 'response.create';
  response?: {
    commit: boolean;
    cancel_previous: boolean;
    append_input_items?: Array<RealtimeRealtimeRequestItem>;
    input_items?: Array<RealtimeRealtimeRequestItem>;
    instructions?: string;
    modalities?: Array<'text' | 'audio'>;
    voice?: RealtimeRealtimeVoice;
    temperature?: number;
    max_output_tokens?: number | 'inf' | null;
    tools?: Array<RealtimeRealtimeTool>;
    tool_choice?: RealtimeRealtimeToolChoice;
    output_audio_format?: RealtimeRealtimeAudioFormat;
  };
};

export type RealtimeRealtimeRequestSessionUpdateCommand = RealtimeRealtimeRequestCommand & {
  type: 'session.update';
} & {
  type: 'session.update';
  session: {
    model?: RealtimeRealtimeRequestModel;
    modalities?: Array<'text' | 'audio'>;
    voice?: RealtimeRealtimeVoice;
    instructions?: string;
    input_audio_format?: RealtimeRealtimeAudioFormat;
    output_audio_format?: RealtimeRealtimeAudioFormat;
    input_audio_transcription?: RealtimeRealtimeAudioInputTranscriptionSettings;
    turn_detection?: RealtimeRealtimeTurnDetection | RealtimeRealtimeServerVadTurnDetection;
    tools?: Array<RealtimeRealtimeTool>;
    tool_choice?: RealtimeRealtimeToolChoice;
    temperature?: number;
    max_response_output_tokens?: number | 'inf';
  };
};

export type RealtimeRealtimeRequestSystemMessageItem = RealtimeRealtimeRequestMessageItem & {
  role: 'system';
} & {
  role: 'system';
  content: Array<RealtimeRealtimeRequestTextContentPart>;
};

export type RealtimeRealtimeRequestTextContentPart = RealtimeRealtimeContentPart & {
  type: 'input_text';
} & {
  type: 'input_text';
  text: string;
};

export type RealtimeRealtimeRequestUserMessageItem = RealtimeRealtimeRequestMessageItem & {
  role: 'user';
} & {
  role: 'user';
  content: Array<RealtimeRealtimeRequestTextContentPart | RealtimeRealtimeRequestAudioContentPart>;
};

export interface RealtimeRealtimeResponse {
  object: 'realtime.response';
  id: string;
  status: RealtimeRealtimeResponseStatus;
  status_details: (RealtimeRealtimeResponseStatusDetails & {
    type: 'Realtime.RealtimeResponse';
  }) | null;
  output: Array<RealtimeRealtimeResponseItem>;
  usage: {
    total_tokens: number;
    input_tokens: number;
    output_tokens: number;
    input_token_details: {
      cached_tokens: number;
      text_tokens: number;
      audio_tokens: number;
    };
    output_token_details: {
      text_tokens: number;
      audio_tokens: number;
    };
  };
}

export interface RealtimeRealtimeResponseApiError {
  type: string;
  code?: string;
  message: string;
  param?: string;
}

export type RealtimeRealtimeResponseAudioContentPart = RealtimeRealtimeContentPart & {
  type: 'audio';
} & {
  type: 'audio';
  transcript: string | null;
};

export type RealtimeRealtimeResponseAudioDeltaCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.audio.delta';
} & {
  type: 'response.audio.delta';
  response_id: string;
  item_id: string;
  output_index: number;
  content_index: number;
  delta: string;
};

export type RealtimeRealtimeResponseAudioDoneCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.audio.done';
} & {
  type: 'response.audio.done';
  response_id: string;
  item_id: string;
  output_index: number;
  content_index: number;
};

export type RealtimeRealtimeResponseAudioTranscriptDeltaCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.audio_transcript.delta';
} & {
  type: 'response.audio_transcript.delta';
  response_id: string;
  item_id: string;
  output_index: number;
  content_index: number;
  delta: string;
};

export type RealtimeRealtimeResponseAudioTranscriptDoneCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.audio_transcript.done';
} & {
  type: 'response.audio_transcript.done';
  response_id: string;
  item_id: string;
  output_index: number;
  content_index: number;
  transcript: string;
};

export type RealtimeRealtimeResponseCancelledStatusDetails = RealtimeRealtimeResponseStatusDetails & {
  type: 'cancelled';
} & {
  type: 'cancelled';
  reason: 'turn_detected' | 'client_cancelled';
};

/**
 * Base representation of a WebSocket message received from the service.
 */
export interface RealtimeRealtimeResponseCommand {
  type: RealtimeRealtimeResponseCommandType;
  event_id: string | null;
}

// export type RealtimeRealtimeResponseCommandType = string | ('session.created' | 'session.updated' | 'conversation.item.created' | 'conversation.item.deleted' | 'conversation.item.truncated' | 'response.created' | 'response.done' | 'rate_limits.updated' | 'response.output_item.added' | 'response.output_item.done' | 'response.content_part.added' | 'response.content_part.done' | 'response.audio.delta' | 'response.audio.done' | 'response.audio_transcript.delta' | 'response.audio_transcript.done' | 'response.text.delta' | 'response.text.done' | 'response.function_call_arguments.delta' | 'response.function_call_arguments.done' | 'input_audio_buffer.speech_started' | 'input_audio_buffer.speech_stopped' | 'conversation.item.input_audio_transcription.completed' | 'conversation.item.input_audio_transcription.failed' | 'input_audio_buffer.committed' | 'input_audio_buffer.cleared' | 'error');
export type RealtimeRealtimeResponseCommandType = string | (RealtimeResponseCommandEnum | `${RealtimeResponseCommandEnum}`);

export type RealtimeRealtimeResponseContentPartAddedCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.content_part.added';
} & {
  type: 'response.content_part.added';
  response_id: string;
  item_id: string;
  output_index: number;
  content_index: number;
  part: RealtimeRealtimeContentPart;
};

export type RealtimeRealtimeResponseContentPartDoneCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.content_part.done';
} & {
  type: 'response.content_part.done';
  response_id: string;
  item_id: string;
  output_index: number;
  content_index: number;
  part: RealtimeRealtimeContentPart;
};

export type RealtimeRealtimeResponseCreatedCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.created';
} & {
  type: 'response.created';
  response: RealtimeRealtimeResponse;
};

export type RealtimeRealtimeResponseDoneCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.done';
} & {
  type: 'response.done';
  response: RealtimeRealtimeResponse;
};

export interface RealtimeRealtimeResponseError {
  type: string;
  code?: string;
  message: string;
  param?: string;
  event_id?: string;
}

/**
 * A command that describes an error encountered during a realtime operation.
 */
export type RealtimeRealtimeResponseErrorCommand = RealtimeRealtimeResponseCommand & {
  type: 'error';
} & {
  type: 'error';
  error: RealtimeRealtimeResponseError;
};

export type RealtimeRealtimeResponseFailedStatusDetails = RealtimeRealtimeResponseStatusDetails & {
  type: 'failed';
} & {
  type: 'failed';
  error: unknown;
};

export type RealtimeRealtimeResponseFunctionCallArgumentsDeltaCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.function_call_arguments.delta';
} & {
  type: 'response.function_call_arguments.delta';
  response_id: string;
  item_id: string;
  output_index: number;
  call_id: string;
  delta: string;
};

export type RealtimeRealtimeResponseFunctionCallArgumentsDoneCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.function_call_arguments.done';
} & {
  type: 'response.function_call_arguments.done';
  response_id: string;
  item_id: string;
  output_index: number;
  call_id: string;
  name: string;
  arguments: string;
};

export type RealtimeRealtimeResponseFunctionCallItem = RealtimeRealtimeResponseItem & {
  type: 'function_call';
} & {
  type: 'function_call';
  name: string;
  call_id: string;
  arguments: string;
  status: RealtimeRealtimeItemStatus;
};

export type RealtimeRealtimeResponseFunctionCallOutputItem = RealtimeRealtimeResponseItem & {
  type: 'function_call_output';
} & {
  type: 'function_call_output';
  call_id: string;
  output: string;
};

export type RealtimeRealtimeResponseIncompleteStatusDetails = RealtimeRealtimeResponseStatusDetails & {
  type: 'incomplete';
} & {
  type: 'incomplete';
  reason: 'max_output_tokens' | 'content_filter';
};

export type RealtimeRealtimeResponseInputAudioBufferClearedCommand = RealtimeRealtimeResponseCommand & {
  type: 'input_audio_buffer.cleared';
} & {
  type: 'input_audio_buffer.cleared';
};

export type RealtimeRealtimeResponseInputAudioBufferCommittedCommand = RealtimeRealtimeResponseCommand & {
  type: 'input_audio_buffer.committed';
} & {
  type: 'input_audio_buffer.committed';
  item_id: string;
  previous_item_id?: string;
};

export type RealtimeRealtimeResponseInputAudioBufferSpeechStartedCommand = RealtimeRealtimeResponseCommand & {
  type: 'input_audio_buffer.speech_started';
} & {
  type: 'input_audio_buffer.speech_started';
  audio_start_ms: number;
  item_id: string;
};

export type RealtimeRealtimeResponseInputAudioBufferSpeechStoppedCommand = RealtimeRealtimeResponseCommand & {
  type: 'input_audio_buffer.speech_stopped';
} & {
  type: 'input_audio_buffer.speech_stopped';
  audio_end_ms: number;
  item_id: string;
};

export interface RealtimeRealtimeResponseItem {
  object: 'realtime.item';
  type: RealtimeRealtimeItemType;
  id: string | null;
}

export type RealtimeRealtimeResponseItemCreatedCommand = RealtimeRealtimeResponseCommand & {
  type: 'conversation.item.created';
} & {
  type: 'conversation.item.created';
  item: RealtimeRealtimeResponseItem;
};

export type RealtimeRealtimeResponseItemDeletedCommand = RealtimeRealtimeResponseCommand & {
  type: 'conversation.item.deleted';
} & {
  type: 'conversation.item.deleted';
  item_id: string;
};

export type RealtimeRealtimeResponseItemInputAudioTranscriptionCompletedCommand = RealtimeRealtimeResponseCommand & {
  type: 'conversation.item.input_audio_transcription.completed';
} & {
  type: 'conversation.item.input_audio_transcription.completed';
  item_id: string;
  content_index: number;
  transcript: string;
};

export type RealtimeRealtimeResponseItemInputAudioTranscriptionFailedCommand = RealtimeRealtimeResponseCommand & {
  type: 'conversation.item.input_audio_transcription.failed';
} & {
  type: 'conversation.item.input_audio_transcription.failed';
  item_id: string;
  content_index: number;
  error: RealtimeRealtimeResponseApiError;
};

export type RealtimeRealtimeResponseItemTruncatedCommand = RealtimeRealtimeResponseCommand & {
  type: 'conversation.item.truncated';
} & {
  type: 'conversation.item.truncated';
  item_id: string;
  audio_end_ms: number;
  index: number;
};

export type RealtimeRealtimeResponseMessageItem = RealtimeRealtimeResponseItem & {
  type: 'message';
} & {
  type: 'message';
  role: RealtimeRealtimeMessageRole;
  content: Array<RealtimeRealtimeContentPart>;
  status: RealtimeRealtimeItemStatus;
};

export type RealtimeRealtimeResponseOutputItemAddedCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.output_item.added';
} & {
  type: 'response.output_item.added';
  response_id: string;
  output_index: number;
  item: RealtimeRealtimeResponseItem;
};

export type RealtimeRealtimeResponseOutputItemDoneCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.output_item.done';
} & {
  type: 'response.output_item.done';
  response_id: string;
  output_index: number;
  item: RealtimeRealtimeResponseItem;
};

export interface RealtimeRealtimeResponseRateLimitDetailsItem {
  name: string;
  limit: number;
  remaining: number;
  reset_seconds: number;
}

export type RealtimeRealtimeResponseRateLimitsUpdatedCommand = RealtimeRealtimeResponseCommand & {
  type: 'rate_limits.updated';
} & {
  type: 'rate_limits.updated';
  rate_limits: Array<RealtimeRealtimeResponseRateLimitDetailsItem>;
};

export interface RealtimeRealtimeResponseSession {
  object: 'realtime.session';
  id: string;
  model: string;
  modalities: Array<'text' | 'audio'>;
  instructions: string;
  voice: RealtimeRealtimeVoice;
  input_audio_format: RealtimeRealtimeAudioFormat;
  output_audio_format: RealtimeRealtimeAudioFormat;
  input_audio_transcription: RealtimeRealtimeAudioInputTranscriptionSettings | null;
  turn_detection: RealtimeRealtimeTurnDetection;
  tools: Array<RealtimeRealtimeTool>;
  tool_choice: RealtimeRealtimeToolChoice;
  temperature: number;
  max_response_output_tokens: number | null;
}

export type RealtimeRealtimeResponseSessionCreatedCommand = RealtimeRealtimeResponseCommand & {
  type: 'session.created';
} & {
  type: 'session.created';
  session: RealtimeRealtimeResponseSession;
};

export type RealtimeRealtimeResponseSessionUpdatedCommand = RealtimeRealtimeResponseCommand & {
  type: 'session.updated';
} & {
  type: 'session.updated';
  session: RealtimeRealtimeResponseSession;
};

export type RealtimeRealtimeResponseStatus = string | ('in_progress' | 'completed' | 'cancelled' | 'incomplete' | 'failed');

export interface RealtimeRealtimeResponseStatusDetails {
  type: RealtimeRealtimeResponseStatus;
}

export type RealtimeRealtimeResponseTextContentPart = RealtimeRealtimeContentPart & {
  type: 'text';
} & {
  type: 'text';
  text: string;
};

export type RealtimeRealtimeResponseTextDeltaCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.text.delta';
} & {
  type: 'response.text.delta';
  response_id: string;
  item_id: string;
  output_index: number;
  content_index: number;
  delta: string;
};

export type RealtimeRealtimeResponseTextDoneCommand = RealtimeRealtimeResponseCommand & {
  type: 'response.text.done';
} & {
  type: 'response.text.done';
  response_id: string;
  item_id: string;
  output_index: number;
  content_index: number;
  value: string;
};

export type RealtimeRealtimeServerVadTurnDetection = RealtimeRealtimeTurnDetection & {
  type: 'server_vad';
} & {
  type: 'server_vad';
  threshold?: number;
  prefix_padding_ms?: string;
  silence_duration_ms?: string | number;
};

/**
 * The base representation of a realtime tool definition.
 */
export interface RealtimeRealtimeTool {
  type: RealtimeRealtimeToolType;
}

/**
 * The combined set of available representations for a realtime tool_choice parameter, encompassing both string
 * literal options like 'auto' as well as structured references to defined tools.
 */
export type RealtimeRealtimeToolChoice = RealtimeRealtimeToolChoiceLiteral | RealtimeRealtimeToolChoiceObject;

/**
 * The representation of a realtime tool_choice selecting a named function tool.
 */
export type RealtimeRealtimeToolChoiceFunctionObject = RealtimeRealtimeToolChoiceObject & {
  type: 'function';
} & {
  type: 'function';
  function: {
    name: string;
  };
};

/**
 * The available set of mode-level, string literal tool_choice options for the realtime endpoint.
 */
export type RealtimeRealtimeToolChoiceLiteral = string | ('auto' | 'none' | 'required');

/**
 * A base representation for a realtime tool_choice selecting a named tool.
 */
export interface RealtimeRealtimeToolChoiceObject {
  type: RealtimeRealtimeToolType;
}

/**
 * The supported tool type discriminators for realtime tools.
 * Currently, only 'function' tools are supported.
 */
export type RealtimeRealtimeToolType = string | 'function';

export interface RealtimeRealtimeTurnDetection {
  type: RealtimeRealtimeTurnDetectionType;
}

export type RealtimeRealtimeTurnDetectionType = string | 'server_vad';

export type RealtimeRealtimeVoice = string | ('alloy' | 'shimmer' | 'echo');

export interface RealtimeStartRealtimeSessionData {
  body: Array<RealtimeRealtimeRequestCommand>;
  path?: never;
  query?: never;
  url: '/realtime';
}

export interface RealtimeStartRealtimeSessionResponses {
  /**
   * The request has succeeded.
   */
  200: Array<RealtimeRealtimeResponseCommand>;
}

export type RealtimeStartRealtimeSessionResponse = RealtimeStartRealtimeSessionResponses[keyof RealtimeStartRealtimeSessionResponses];

export interface ClientOptions {
  baseUrl: 'https://api.openai.com' | (string & {});
}
